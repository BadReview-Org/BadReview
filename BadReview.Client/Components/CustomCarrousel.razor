@typeparam T
@inject NavigationManager Navigation
@inject ApiService ApiService

<MudPaper Class="pa-6 mb-8" Elevation="6" Style="background: linear-gradient(145deg, #2a2a2a, #1a1a1a); border-radius: 12px;">
    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Class="mb-4">
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Style="min-width: 200px; width: 200px;">
            <MudIcon Icon="@Icon" Color="Color.Primary" Size="Size.Large" />
            <MudText Typo="Typo.h4" Style="font-weight: 600; color: #667eea;">
                @Title
            </MudText>
        </MudStack>
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Style="min-width: 300px; width: 500px;">
        <CustomDropdown T="T"  DropdownChanged="OnDropdownSelected" SearchElements="OnSearchElements" Label="Search for games..." >
        <ItemTemplate Context ="element">
            @DropdownTemplate(element)
        </ItemTemplate>
        </CustomDropdown>
        </MudStack>
        <MudStack Row="true" Spacing="1">
            <MudIconButton Icon="@Icons.Material.Filled.ChevronLeft" 
                          Color="Color.Primary" 
                          OnClick="() => Scroll(1)" />
            <MudIconButton Icon="@Icons.Material.Filled.ChevronRight" 
                          Color="Color.Primary" 
                          OnClick="() => Scroll(-1)" />
        </MudStack>
    </MudStack>
    <div style="overflow: hidden;">
        <MudStack Row="true" Spacing="3" Style="@GetScrollStyle(scrollPosition)">
            @* Duplicar items al inicio para scroll infinito *@
            @foreach (var item in Items)
            {
                <MudCard Class="carousel-card" 
                        Style="min-width: 200px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); cursor: pointer;"
                        @onclick="@(() => OnItemClick.InvokeAsync(item))"
                        @onmouseenter="() => {_open = true;}"
                        @onmouseleave="() => {_open = false;}"
                        >
                    <MudCardContent Class="d-flex flex-column align-center justify-center pa-4" Style="height: 150px;">
                        @ItemTemplate(item)
                    </MudCardContent>
                </MudCard>
            }
            @* Items originales *@
            @foreach (var item in Items)
            {
                <MudCard Class="carousel-card mud-elevation-hover" 
                        Style="min-width: 200px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); cursor: pointer;"
                        @onclick="@(() => OnItemClick.InvokeAsync(item))"
                        @onmouseenter="() => {_open = true;}"
                        @onmouseleave="() => {_open = false;}"
                        >
                    <MudCardContent Class="d-flex flex-column align-center justify-center pa-4" Style="height: 150px;">
                        @ItemTemplate(item)
                    </MudCardContent>
                </MudCard>
            }
            @* Duplicar items al final para scroll infinito *@
            @foreach (var item in Items)
            {
                <MudCard Class="carousel-card mud-elevation-hover" 
                        Style="min-width: 200px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); cursor: pointer;"
                        @onclick="@(() => OnItemClick.InvokeAsync(item))"
                        >
                    <MudCardContent Class="d-flex flex-column align-center justify-center pa-4" Style="height: 150px;">
                        @ItemTemplate(item)
                    </MudCardContent>
                </MudCard>
            }
        </MudStack>
    </div>
</MudPaper>

@code {
    [Parameter] public List<T> Items { get; set; } = new();
    [Parameter] public string Title { get; set; } = "";
    [Parameter] public string Icon { get; set; } = Icons.Material.Filled.Category;
    [Parameter] public RenderFragment<T> ItemTemplate { get; set; } = null!;

    [Parameter] public RenderFragment<T> DropdownTemplate { get; set; } = null!;
    [Parameter] public EventCallback<T> OnItemClick { get; set; }
    [Parameter] public EventCallback<T> DropdownChanged { get; set; }

    [Parameter] public string URI { get; set; } = "";
    
    private int scrollPosition = 0;
    private const int cardWidth = 220; // ancho de card + spacing
    private bool isTransitioning = true;
    private bool _open = false;

    private string _searchText = string.Empty;
    protected override void OnInitialized()
    {
        // Empezar en la posición del primer set de items (después de los duplicados iniciales)
        scrollPosition = -(Items.Count * cardWidth);
    }

    private void Scroll(int direction)
    {
        isTransitioning = true;
        scrollPosition += direction * cardWidth;
        
        StateHasChanged();
        
        // Después de la animación, verificar si necesitamos "saltar" sin animación
        _ = Task.Delay(500).ContinueWith(_ =>
        {
            InvokeAsync(() =>
            {
                var totalWidth = Items.Count * cardWidth;
                var minPosition = -(totalWidth * 2); // Límite izquierdo (final del segundo set)
                var maxPosition = 0; // Límite derecho (inicio del primer set)
                
                // Si llegamos al final (scroll izquierda), saltar al inicio del set original
                if (scrollPosition <= minPosition)
                {
                    isTransitioning = false;
                    scrollPosition = -(Items.Count * cardWidth);
                    StateHasChanged();
                }
                // Si llegamos al inicio (scroll derecha), saltar al final del set original
                else if (scrollPosition >= maxPosition)
                {
                    isTransitioning = false;
                    scrollPosition = -(Items.Count * cardWidth);
                    StateHasChanged();
                }
            });
        });
    }

    private string GetScrollStyle(int position)
    {
        var transition = isTransitioning ? "transition: transform 0.5s ease;" : "";
        return $"transform: translateX({position}px); {transition}";
    }

    private async Task<IEnumerable<T>> OnSearchElements(string searchText)
    {    
        ApiRequest apiRequest = new ApiRequest{
            URI = URI, 
            PageSize = 30,
            Page = 0 };

        if (string.IsNullOrWhiteSpace(searchText))
        {
            // Retornar todos los juegos
            var allElements = await ApiService.GetManyAsync<T>(apiRequest);
            return allElements?.Data ?? Enumerable.Empty<T>();
        }
        apiRequest.Filters = $"@name ~ *\"{searchText}\"*";
        PagedResult<T>? responseDto = await ApiService.GetManyAsync<T>(apiRequest);
        if (responseDto != null)
        {
            return responseDto?.Data ?? Enumerable.Empty<T>();
        }
        return Enumerable.Empty<T>();
    }

    private void OnDropdownSelected(T element){
        DropdownChanged.InvokeAsync(element);
    }

}